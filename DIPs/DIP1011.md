# External and Untyped Member Functions

| Field           | Value                                                           |
|-----------------|-----------------------------------------------------------------|
| DIP:            | 1011                                                            |
| RC#             | 1 [Most Recent]                                                 |
| Author:         | Jonathan Marler - johnnymarler@gmail.com                        |
| Implementation: | None                                                            |
| Status:         | Formal Review                                                   |

[Most Recent]: https://github.com/dlang/DIPs/blob/69b949be79cba566381ad5de146d0ecc9f21dd5a/DIPs/DIP1011.md

## Abstract

It is proposed that

* free functions with a class, struct reference, or `void*` as their first parameter type use the member function ABI.
* taking the address of a UFCS call to a function that meets the previous criteria creates a delegate.
* the `funcptr` member of all delegate types add an additional parameter of type `void*` as the first parameter.
* function pointers with a class or struct reference as the first parameter type be implicitly convertible to a function pointer with the same arguments but substituting the first parameter for `void*`.

### Links

[General forum discussion](http://forum.dlang.org/post/qtaiotodqqxqoqmozgrq@forum.dlang.org)

## Terminology

A "free function" is a function that does not have a context pointer.  Member functions and nested functions are not free functions, however, static functions are always free functions.

A free function with a class or struct reference or as its first parameter is said to meet the "external member criteria".

A free function with `void*` as its first parameter is said to meet the "untyped member criteria".

An "external member function" is a function that meets the external member criteria, and uses the same ABI as a member function with the first parameter being the context pointer.

An "untyped member function" is a function that meets the untyped member criteria, and uses the same ABI as a member function with the first parameter being the context pointer.

## Description

It is proposed that functions meeting the external member criteria adopt the same ABI as their regular member function counterparts, i.e.

#### Example 1:
```D
class Class
{
    void memberFunc(int x, float y);
}
// same ABI as memberFunc
void externalMemberFunc(Class c, int x, float y);
```

#### Example 2:
```D
struct Struct
{
    void memberFunc(int x, float y);
}
// same ABI as memberFunc
void externalMemberFunc1(ref Struct s, int x, float y);
// same ABI as memberFunc
void externalMemberFunc2(Struct* s, int x, float y);
```

In addition to external member functions, it is also proposed that functions meeting the untyped member criteria (have `void*` as their first parameter) also use the member function ABI where the first parameter is passed in the same way as the context pointer.
```D
// same ABI as memberFunc from the previous examples
void untypedMemberFunction(void* p, int x, float y);
```

### UFCS delegate retrieval

Along with the ABI changes, it is also proposed that taking the address of a UFCS call with an external member function creates a delegate just like it would with a regular member function.

```D
void bar(Class);
Class c;
void delegate() dg = &c.bar;   // uses UFCS to get a "void delegate()" with the context pointer set to c
```

By using UFCS to retrieve a delegate, the same syntax is used for regular and external member functions, namely, `&<object>.<function>`. This allows templates and mixins to work with both kinds. It also maintains type safety between the context pointer and the first parameter of the function by "piggy-backing" off the type checking done by the UFCS call.

### All delegate `.funcptr` fields should be untyped member functions

Note that this ABI change also applies to function pointers.  Because of this, it's necessary to revise the `funcptr` field for delegates.  Consider,

```D
void externalMemberFunc(Class1 c1, Class2 c2) { }
void delegate(Class2 c2) dg = &(new Class1().externalMemberFunc);

void function(Class2)       func = dg.funcptr; // today
void function(void*,Class2) func = dg.funcptr; // proposed
```

With the new external member criteria applied to the current definition of `funcptr`, the function is incorrectly interpreted as an external member function for `Class2`. Rather, it is actually a external member function for `Class1`.

With the revised definition of `funcptr`, it correctly indicates with `void*` that the context pointer is a dynamic type that can change at runtime.  This also causes it to meet the untyped member criteria making it an untyped member function.

To minimize code breakage from changing `funcptr`, and prevent the need for casting, it is also proposed that all member functions (regular and external) be implicitly convertible to their untyped member function counterparts, i.e.

```D
void function(Class)      func1;
void function(ref Struct) func2;
void function(Struct*)    func3;

void function(void*) voidFunc = func1; // ok
void function(void*) voidFunc = func2; // ok
void function(void*) voidFunc = func3; // ok
```

Here's an example showing how it can be used with delegates:
```D
void func1(Class);
void func2(ref Struct);

void delegate() dg;
dg.ptr = new Class();
dg.funcptr = &func1;

Struct s;
dg.ptr = &s;
dg.funcptr = &func2;
```

### Mangling

Mangling should work just like before in that functions that use the member function ABI should use the member function name mangling rules.  The new external member functions will use the member function mangling rules.  However, I'm not sure how untyped member functions will be mangled yet, I'll need to become more familiar with the name mangling rules to know how it should be done.

## Rationale

This proposal allows external member functions to be called as delegates with zero overhead.

```D
void foo(Class c, int x, float y);
auto c = new Class;
void delegate(int,float) dg = &c.foo;
```
> Note: this use case is different from the `std.functional.toDelegate` method, which can create a delegate from a function but does not allow the function to make use of the context pointer.

It also fixes the type of the `.funcptr` field of delegates so that its type correctly represents its ABI, i.e.

```D
void delegate() dg;

void function()      fp = dg.funcptr; // today
void function(void*) fp = dg.funcptr; // with this proposal
```

External member functions allow developers to write functions that can be called via delegates even when they cannot be added as member functions (i.e. because the class/struct may be defined in another library like druntime or phobos).

#### Use Cases

There are 2 types of use cases I've identified:

* **Type 1**: Need a delegate where the context pointer is an external type that such that member functions can't be added.
* **Type 2**: Want to call an external function through a delegate.  I should look for functions in druntime/phobos that take template parameters as their first argument that I want to call as delegates.

##### Type 2 Candidates
```D
// object.d, destroy
Struct s;
void delegate() destroyDg = &s.destroy;
Object o;
void delegate(Object o) opEqualsDg = &o.opEquals;
```
```D
// std.range
MyRange range;
void delegate() reverseDg = &range.retro;
void delegate() radialDg = &range.radial;
void delegate() takeOneDg = &range.takeOne;
void delegate() takeNone = &range.takeNone;
void delegate(size_t) takeExactlyDg = &range.takeExactly;
void delegate(size_t) takeDg = &range.take;
void delegate(size_t) strideDg = &range.stride;
void delegate(size_t) tailDg = &range.tail;
void delegate(size_t) dropDg = &range.drop;
// TODO: how would these delegates be retrieved today?
```

```D
T[] rawReadAndCapitalize(T)(ref File file, T[] buffer)
{
    auto result = file.rawRead(buffer);
    foreach (i; 0 .. result.length)
    {
        result[i] = result[i].toUpper;
    }
}

void dump(T)(T[] delegate(T[] buffer) reader)
{
    T[1024] buffer;
    for (;;)
    {
        auto data = reader(buffer);
        if (data.length == 0)
            break;
        write(data);
    }
}

void main()
{
    File file = File("file.txt", "r");
    dump(&file.rawReadAndCapitalize);
}
```


#### Alternative Solutions

Say we want to create a delegate function that takes a `std.stdio.File` reference as the context pointer. Let's call it `writelnWithTime` and have it write a line to the file prefixed with the current time. Normally, functions intended to be used as delegates are added to a type as member functions, but member functions cannot be added to `std.stdio.File` because it is defined in the standard library. One solution is to create a wrapper type and define our new delegate function inside the wrapper, e.g.

```D
struct FileWrapper
{
    File* file;
    void writelnWithTime(string msg)
    {
        file.writeln(Clock.currTime, " ", msg);
    }
}

File file;
auto wrapper = FileWrapper(&file);
auto ourDelegate = &wrapper.writelnWithTime;
```

This works, but comes at a cost. It adds complexity in ownership semantics, potential for scoping errors, unnecessary runtime overhead, an extra level of indirection, and requires extra boilerplate code at the call site to instantiate the wrapper type. The worst problem with this solution is it requires a proliferation of wrapper types. If we define this wrapper in a library that is used by an application, and that application needs to add its own delegate functions, then it must create a "wrapper-wrapper" type, introducing another level of indirection. This adds no value to the program, but does introduce overhead and complexity.

Another solution is to throw type safety out the window, e.g.

```D
struct DummyType
{
    void writelnWithTime(string msg)
    {
        File* file = cast(File*)&this;
        file.writeln(Clock.currTime, " ", msg);
    }
}

File file;
DummyType dummy;
auto ourDelegate = &dummy.writelnWithTime;
ourDelegate.ptr = cast(void*)&file;
```

This also has a cost. Following are the problems seen at both the definition site and the call site.

#### At the function definition site:

* requires the function to be defined inside a dummy wrapper type
* requires a cast from the dummy type context pointer to the actual type you want; this throws away any type safety of the context pointer type and incurs some runtime overhead

#### At the function call site:

* requires an instance of the dummy type to be declared; note that this declaration has no purpose other than to get a delegate to the function
* once the delegate is retrieved, the `ptr` is set as an independent statement which creates a new place for a runtime error
* to set the delegate context pointer, the type must be cast to a `void*`; like the definition site, this throws away any type safety for the context pointer type and incurs some runtime overhead

Some of the issues at the call site can be mitigated with a helper library, i.e.
```D
// assume this is in the standard library
auto makeUntypedDelegate(T, string Member, U)(U u)
{
    T t;
    auto dg = &__traits(getMember, t, Member);
    dg.ptr = u;
    return dg;
}

struct DummyType
{
    void writelnWithTime(string msg)
    {
        File* file = cast(File*)&this;
        file.writeln(Clock.currTime, " ", msg);
    }
}

File file;
auto ourDelegate = makeUntypedDelegate!(DummyType, "writelnWithTime")(&file);
```
However, even with a helper library the context pointer still can't be type checked and every function you'd like to be able to call through a delegate would need to be defined inside a dummy type.

With external member functions the solution is simple, clear, and type-safe. You don't need to move your functions inside dummy wrapper types, no casting at the definition site or the call site, no runtime overhead, and delegate retrieval happens in one type-safe statement.

```D
void writelnWithTime(ref File file, string msg)
{
    file.writeln(Clock.currTime, " ", msg);
}

File file;
auto ourDelegate = &file.writelnWithTime;
```

### Breaking changes / deprecation process

* Breaks binary compatibility with functions that meet the external and untyped member criterias.  This means libraries will have to be recompiled.
* Breaks code that depends on `funcptr` having a function pointer type without a context pointer. However, there should be a small amount of code (if any) that would depend on this.
* Taking the address of a UFCS call that omits its parenthesis (i.e. `obj.func` rather than `obj.func(...)`) will now have a different meaning if that function returns a reference type. See "The & operator ambiguity" section.

### Examples

Example to demonstrate the usage:
```D
struct Foo
{
    void bar(int x)
    {
    }
}
void baz(ref Foo foo, int x)
{
}

// Note that even though `bar` is defined as a member function inside
// the struct Foo, the `baz` function has an identical ABI with `bar`.

void delegate(int) dg;
Foo foo;

dg = &foo.bar;  // a normal member function delegate
dg(42);         // calls foo.bar(42)

dg = &foo.baz;  // using UFCS to retrieve a delegate to the external member function "baz"
dg(42);         // calls baz(foo, 42);

dg = &baz;      // Error: cannot implicitly convert expression (baz) of type void function(ref Foo, int x) to void delegate(int)
```

A more realistic example:
```D
import std.stdio, std.datetime;

void writelnWithTime(T)(ref File foo, T[] buffer)
{
    foo.writeln(Clock.currTime, " ", buffer);
}

void main()
{
    dumpInfo(&stdout.writeln!(const(char)[]));

    // Using UFCS to get a delegate to the external member function writelnWithTime
    dumpInfo(&stdout.writelnWithTime!(const(char)[]))
}

void dumpInfo(void delegate(const(char)[]) writer)
{
    writer("Some Info:");
    writer("  2 = 2");
    writer("  3 != 4");
}
```

It is worth noting that external member functions can be imitated with existing semantics at the cost of type-safety and odd looking code with unclear intentions. The previous example could be "emulated" today like this:
```D
import std.stdio, std.datetime;

// Since there's currently no way to define a function that is ABI-compatible
// with a delegate, we must define our function as a method on a "dummy" type.
// The odd part is that we will be casting the "this" argument to the real
// type we are going to operate on, which in this case is a File*.
struct DummyType
{
    void writelnWithTime(T)(T[] buffer)
    {
        File* file = cast(File*)&this;
        file.writeln(Clock.currTime, " ", buffer);
    }
}

void main()
{
    dumpInfo(&stdout.writeln!(const(char)[]));

    // The DummyType "dummy" variable has no fields and takes no memory.
    // It's only purpose is to create a delegate to the method we want to call.
    DummyType dummy;
    auto writer = &dummy.writelnWithTime!(const(char));

    // Here's where we override the dummy ptr with the real object
    // we want to call the delegate with.
    writer.ptr = &stdout;

    dumpInfo(writer);
}

void dumpInfo(void delegate(const(char)[]) writer)
{
    writer("Some Info:");
    writer("  2 = 2");
    writer("  3 != 4");
}
```

### More Use Cases

Delegates only have one context pointer, which means functions that already use the context pointer like member functions or nested functions cannot add a second context pointer to become external member functions of their first parameter type. A function that is already a member/nested function is not considered a "free function" so it doesn't meet the criteria of an external member function.  The exception is if the function is static, in which case it does become an external member function.  For example:
```D
struct Foo
{
    // foo is a member function of Foo, so it is not a free function and cannot be an
    // external member function of Bar
    void foo(Bar bar)
    {
    }
    // foo2 is static so it IS NOT a member function of Foo so it becomes an external
    // member function of Bar
    static void foo2(Bar bar)
    {
        // foo3 is a nested function so it cannot be an external member function of Bar
        void foo3(Bar bar)
        {
        }
        // foo4 is static, so it does not have a context pointer to the parent function so
        // it is an external member function of Bar
        static void foo4(Bar bar)
        {
        }
    }
}
```

## The & operator ambiguity

Taking the address of a dotted member function (`&<object>.<member-function>`) creates a delegate. The same syntax can be used for a UFCS call with no arguments (`&<first-argument>.<non-member-function>`); however, in this case it is interpreted as taking the address of the return value of a call to the function with no arguments e.g.

```D
struct Foo
{
    ref int bar1() { /* ... */ }
}
ref int bar2(ref Foo foo) { /* ... */ }

Foo foo;
auto a = &foo.bar1; // creates a delegate, type of a is ref int delegate()
auto b = &foo.bar2; // calls function bar2 and takes the address of the return
                    // value, type of b is int*
```

Note that even though the member function call could be interpreted in the same manner as the UFCS call, the '&' operator gives precedence to intepreting it as a delegate. It is recommended that external member functions behave the same way as member functions in this case for two reasons. The first is that it maintains consistent syntax between regular and external member functions making it easier for templates/mixins to work with both kinds. The second reason is that with this precedence, there currently exists syntax that expresses the intent to call the function and take the address of the return value, namely, by including an empty parameter list `()` e.g.
```D
ref int bar(ref Foo foo) { /* ... */ }
Foo foo;
auto a = &foo.bar;   // should create a delegate, type of a should be
                     // ref int delegate()
auto b = &foo.bar(); // this is clearly taking the address of the return
                     // value after calling the function, type of b is int*
```
If external member functions do not maintain this precedence, there is currently no syntax that expresses the intent to create a delegate rather than take the address of the return value reference.

## Copyright & License

Copyright (c) 2017 by the D Language Foundation

Licensed under [Creative Commons Zero 1.0](https://creativecommons.org/publicdomain/zero/1.0/legalcode.txt)

## Review

[Preliminary Review Round 1](http://forum.dlang.org/post/topmfucguenqpucsbhwi@forum.dlang.org)